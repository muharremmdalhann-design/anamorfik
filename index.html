<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Anamorphic Cube - STABLE VERSION</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
<style>
body { margin:0; overflow:hidden; background:black; }
video { display:none; }
</style>
</head>
<body>

<video id="video" autoplay playsinline muted></video>

<script type="module">

import {
  FaceLandmarker,
  HandLandmarker,
  FilesetResolver
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

const video = document.getElementById("video");

let faceX=0, faceY=0;
let cubeRotX=0, cubeRotY=0;
let targetExplode=0;

let lastVideoTime=-1;
let lastPredictionTime=0;
const targetFPS=30;
const frameInterval=1000/targetFPS;

// ðŸ”¥ STABILITY VARIABLES
let openFrameCount=0;
let closedFrameCount=0;
const REQUIRED_FRAMES=6;

async function init(){

  const stream = await navigator.mediaDevices.getUserMedia({
    video:{ width:256, height:192 }
  });

  video.srcObject = stream;
  await video.play();

  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
  );

  const faceLandmarker = await FaceLandmarker.createFromOptions(vision,{
    baseOptions:{
      modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task",
      delegate:"GPU"
    },
    runningMode:"VIDEO",
    numFaces:1
  });

  const handLandmarker = await HandLandmarker.createFromOptions(vision,{
    baseOptions:{
      modelAssetPath:"https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task",
      delegate:"GPU"
    },
    runningMode:"VIDEO",
    numHands:1
  });

  function predict(){
    const now=performance.now();

    if(now-lastPredictionTime>=frameInterval){
      if(video.currentTime!==lastVideoTime){

        lastVideoTime=video.currentTime;
        lastPredictionTime=now;

        const faceRes=faceLandmarker.detectForVideo(video,now);
        const handRes=handLandmarker.detectForVideo(video,now);

        // FACE
        if(faceRes.faceLandmarks.length>0){
          const p=faceRes.faceLandmarks[0][1];
          faceX=1.5-(p.x*3);
          faceY=-2.3+(p.y*4.6);
        }

        let isOpen=false;

        // HAND
        if(handRes.landmarks.length>0 && handRes.handednesses.length>0){

          const confidence=handRes.handednesses[0][0].score;

          if(confidence>0.75){

            const lm=handRes.landmarks[0];

            cubeRotY=Math.PI-(lm[9].x*Math.PI*2);
            cubeRotX=Math.PI-(lm[9].y*Math.PI*2);

            function fingerOpen(tip,pip){
              return lm[tip].y<lm[pip].y;
            }

            const openCount=
              (fingerOpen(8,6)?1:0)+
              (fingerOpen(12,10)?1:0)+
              (fingerOpen(16,14)?1:0)+
              (fingerOpen(20,18)?1:0);

            if(openCount>=4){
              isOpen=true;
            }
          }
        }

        // ðŸ”¥ FRAME STABILIZATION
        if(isOpen){
          openFrameCount++;
          closedFrameCount=0;
        }else{
          closedFrameCount++;
          openFrameCount=0;
        }

        if(openFrameCount>=REQUIRED_FRAMES){
          targetExplode=1;
        }

        if(closedFrameCount>=REQUIRED_FRAMES){
          targetExplode=0;
        }
      }
    }

    requestAnimationFrame(predict);
  }

  predict();
}

init();


// ================= P5 =================

let lerpX=0, lerpY=0;
let lerpRotX=0, lerpRotY=0;
let explodeFactor=0;
let cubeEdges=[];

window.setup=function(){
  pixelDensity(1);
  createCanvas(window.innerWidth,window.innerHeight,WEBGL);
  frameRate(targetFPS);

  let s=100;
  cubeEdges=[
    [-s,-s,-s, s,-s,-s,0,-1,-1],
    [ s,-s,-s, s, s,-s,1,0,-1],
    [ s, s,-s,-s, s,-s,0,1,-1],
    [-s, s,-s,-s,-s,-s,-1,0,-1],
    [-s,-s, s, s,-s, s,0,-1,1],
    [ s,-s, s, s, s, s,1,0,1],
    [ s, s, s,-s, s, s,0,1,1],
    [-s, s, s,-s,-s, s,-1,0,1],
    [-s,-s,-s,-s,-s, s,-1,-1,0],
    [ s,-s,-s, s,-s, s,1,-1,0],
    [ s, s,-s, s, s, s,1,1,0],
    [-s, s,-s,-s, s, s,-1,1,0]
  ];
};

window.draw=function(){

  background(0);

  lerpX=lerp(lerpX,faceX,0.1);
  lerpY=lerp(lerpY,faceY,0.1);
  lerpRotX=lerp(lerpRotX,cubeRotX,0.1);
  lerpRotY=lerp(lerpRotY,cubeRotY,0.1);
  explodeFactor=lerp(explodeFactor,targetExplode,0.15);

  camera(0,0,(height/2)/tan(PI*30/180),0,0,0,0,1,0);

  stroke(0,255,200);
  strokeWeight(1.5);
  noFill();
  rectMode(CENTER);
  rect(0,0,width,height);

  drawInterior();
};

function drawInterior(){

  let depth=-800;
  let shiftX=lerpX*400;
  let shiftY=lerpY*250;
  let layers=6;

  for(let i=0;i<=layers;i++){
    let pct=i/layers;
    let z=pct*depth;
    let sX=pct*shiftX;
    let sY=pct*shiftY;

    let c=200-(i*25);
    stroke(0,c,c*0.85);

    push();
    translate(sX,sY,z);
    rect(0,0,width,height);
    pop();

    if(i<layers){
      let next=(i+1)/layers;
      let nz=next*depth;
      let nsX=next*shiftX;
      let nsY=next*shiftY;

      let w=width/2;
      let h=height/2;

      line(-w+sX,-h+sY,z,-w+nsX,-h+nsY,nz);
      line( w+sX,-h+sY,z, w+nsX,-h+nsY,nz);
      line( w+sX, h+sY,z, w+nsX, h+nsY,nz);
      line(-w+sX, h+sY,z,-w+nsX, h+nsY,nz);
    }
  }

  push();
  translate(shiftX*0.5,shiftY*0.5,depth*0.5);
  rotateX(lerpRotX);
  rotateY(lerpRotY);

  stroke(255,0,120);
  strokeWeight(2);

  let moveDist=explodeFactor*180;

  for(let e of cubeEdges){
    let ox=e[6]*moveDist;
    let oy=e[7]*moveDist;
    let oz=e[8]*moveDist;

    line(
      e[0]+ox,e[1]+oy,e[2]+oz,
      e[3]+ox,e[4]+oy,e[5]+oz
    );
  }

  pop();
}

windowResized=function(){
  resizeCanvas(window.innerWidth,window.innerHeight);
};

</script>
</body>
</html>
