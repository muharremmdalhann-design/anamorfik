<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mobile Optimized Anamorphic Cube</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
    canvas { display: block; }
  </style>
</head>
<body>

<script>
let facemesh, handpose;
let video;
let faceX = 0, faceY = 0, lerpX = 0, lerpY = 0;
let cubeRotX = 0, cubeRotY = 0, lerpRotX = 0, lerpRotY = 0;

let explodeFactor = 0; 
let targetExplode = 0;
let cubeEdges = [];

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  
  // MOBİL İÇİN OPTİMİZE EDİLMİŞ KAMERA AYARI
  let constraints = {
    video: {
      facingMode: "user",
      width: { ideal: 320 },
      height: { ideal: 240 }
    },
    audio: false
  };
  
  video = createCapture(constraints);
  video.size(320, 240); 
  video.hide();

  // YÜZ TAKİBİ - PERFORMANS MODU
  facemesh = ml5.facemesh(video, { maxFaces: 1, detectionConfidence: 0.7 }, () => console.log("Yüz Hazır"));
  facemesh.on("predict", results => {
    if (results.length > 0) {
      let p = results[0].scaledMesh[168];
      faceX = map(p[0], 0, 320, 2.3, -2.3); 
      faceY = map(p[1], 0, 240, -2.3, 2.3);
    }
  });

  // EL TAKİBİ - PERFORMANS MODU
  handpose = ml5.handpose(video, { detectionConfidence: 0.7 }, () => console.log("El Hazır"));
  handpose.on("predict", results => {
    if (results.length > 0) {
      let lm = results[0].landmarks;
      cubeRotY = map(lm[9][0], 0, 320, PI, -PI);
      cubeRotX = map(lm[9][1], 0, 240, PI, -PI);
      let handSize = dist(lm[8][0], lm[8][1], lm[5][0], lm[5][1]);
      targetExplode = handSize > 50 ? 1 : 0; // Mesafe değerini mobil için güncelledim
    }
  });

  let s = 110; 
  cubeEdges = [
    {p1: createVector(-s,-s,-s), p2: createVector(s,-s,-s), dir: createVector(0,-1,-1)},
    {p1: createVector(s,-s,-s), p2: createVector(s,s,-s), dir: createVector(1,0,-1)},
    {p1: createVector(s,s,-s), p2: createVector(-s,s,-s), dir: createVector(0,1,-1)},
    {p1: createVector(-s,s,-s), p2: createVector(-s,-s,-s), dir: createVector(-1,0,-1)},
    {p1: createVector(-s,-s,s), p2: createVector(s,-s,s), dir: createVector(0,-1,1)},
    {p1: createVector(s,-s,s), p2: createVector(s,s,s), dir: createVector(1,0,1)},
    {p1: createVector(s,s,s), p2: createVector(-s,s,s), dir: createVector(0,1,1)},
    {p1: createVector(-s,s,s), p2: createVector(-s,-s,s), dir: createVector(-1,0,1)},
    {p1: createVector(-s,-s,-s), p2: createVector(-s,-s,s), dir: createVector(-1,-1,0)},
    {p1: createVector(s,-s,-s), p2: createVector(s,-s,s), dir: createVector(1,-1,0)},
    {p1: createVector(s,s,-s), p2: createVector(s,s,s), dir: createVector(1,1,0)},
    {p1: createVector(-s,s,-s), p2: createVector(-s,s,s), dir: createVector(-1,1,0)}
  ];
}

function draw() {
  background(0);
  
  // YUMUŞATMA DEĞERLERİ (Titremeyi önlemek için hafif artırıldı)
  lerpX = lerp(lerpX, faceX, 0.1);
  lerpY = lerp(lerpY, faceY, 0.1);
  lerpRotX = lerp(lerpRotX, cubeRotX, 0.12);
  lerpRotY = lerp(lerpRotY, cubeRotY, 0.12);
  explodeFactor = lerp(explodeFactor, targetExplode, 0.1);

  camera(0, 0, (height/2.0) / tan(PI*30.0 / 180.0), 0, 0, 0, 0, 1, 0);

  // ÖN ÇERÇEVE
  noFill(); stroke(0, 255, 200); strokeWeight(width > 600 ? 4 : 2);
  rect(0, 0, width, height);

  drawInterior();
}

function drawInterior() {
  let depth = -1500; 
  let shiftX = lerpX * (width * 0.35); // Ekran genişliğine göre dinamik shift
  let shiftY = lerpY * (height * 0.25);
  
  strokeWeight(width > 600 ? 2 : 1);
  for (let i = 0; i <= 9; i++) {
    let pct = i / 9;
    let z = pct * depth;
    let sX = pct * shiftX;
    let sY = pct * shiftY;
    let c = map(i, 0, 9, 200, 30);
    stroke(0, c, c * 0.85);
    push();
    translate(sX, sY, z);
    rect(0, 0, width, height);
    if (i === 9) {
        for (let j = 1; j < 4; j++) {
            let xPos = map(j, 0, 4, -width/2, width/2);
            line(xPos, -height/2, xPos, height/2);
        }
        for (let k = 1; k < 3; k++) {
            let yPos = map(k, 0, 3, -height/2, height/2);
            line(-width/2, yPos, width/2, yPos);
        }
    }
    pop();

    if (i < 9) {
      let nPct = (i + 1) / 9;
      let nsX = nPct * shiftX, nsY = nPct * shiftY, nZ = nPct * depth;
      for (let j = 0; j <= 4; j++) {
          let xOff = map(j, 0, 4, -width/2, width/2);
          line(xOff + sX, -height/2 + sY, z, xOff + nsX, -height/2 + nsY, nZ); 
          line(xOff + sX, height/2 + sY, z, xOff + nsX, height/2 + nsY, nZ);  
      }
      for (let k = 1; k < 3; k++) {
          let yOff = map(k, 0, 3, -height/2, height/2);
          line(-width/2 + sX, yOff + sY, z, -width/2 + nsX, yOff + nsY, nZ); 
          line(width/2 + sX, yOff + sY, z, width/2 + nsX, yOff + nsY, nZ);  
      }
    }
  }

  // MEKANİK KÜP
  push();
  translate(shiftX * 0.5, shiftY * 0.5, depth * 0.5);
  rotateX(lerpRotX);
  rotateY(lerpRotY);
  stroke(255, 0, 100); 
  strokeWeight(width > 600 ? 3 : 1.5);

  let moveDist = explodeFactor * 200; 
  for (let edge of cubeEdges) {
    push();
    translate(edge.dir.x * moveDist, edge.dir.y * moveDist, edge.dir.z * moveDist);
    line(edge.p1.x, edge.p1.y, edge.p1.z, edge.p2.x, edge.p2.y, edge.p2.z);
    pop();
  }
  pop();
}

function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
