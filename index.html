<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anamorphic Corridor Mobile</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>

<script>
let facemesh;
let video;
let predictions = [];
let faceX = 0, faceY = 0;
let lerpX = 0, lerpY = 0;

function setup() {
  // Ekran boyutuna göre canvas oluştur
  createCanvas(windowWidth, windowHeight, WEBGL);
  
  // Kamera ayarları (Mobil ön kamera desteği için)
  let constraints = {
    video: {
      facingMode: "user"
    },
    audio: false
  };
  
  video = createCapture(constraints);
  video.size(320, 240); // Mobil performansı için düşük çözünürlük ideal
  video.hide();

  facemesh = ml5.facemesh(video, () => console.log("Yüz Takibi Aktif"));
  facemesh.on("predict", results => {
    predictions = results;
    if (predictions.length > 0) {
      let p = predictions[0].scaledMesh[168];
      // Takibi ekran oranına göre normalize et
      faceX = map(p[0], 0, 320, 2, -2);
      faceY = map(p[1], 0, 240, -2, 2);
    }
  });
}

function draw() {
  background(0);

  lerpX = lerp(lerpX, faceX, 0.15);
  lerpY = lerp(lerpY, faceY, 0.15);

  // FOV ve Camera ayarı ekran oranına (aspect ratio) göre dinamik yapılır
  let aspect = width / height;
  camera(0, 0, (height/2.0) / tan(PI*30.0 / 180.0), 0, 0, 0, 0, 1, 0);

  // 1. SABİT ÖN ÇERÇEVE
  noFill();
  stroke(0, 255, 200);
  strokeWeight(4);
  rectMode(CENTER);
  // Ekranın tam kenarlarına yapışması için width ve height kullanıyoruz
  rect(0, 0, width, height);

  drawInterior();
}

function drawInterior() {
  // Derinlik ekran yüksekliğine göre orantılanabilir, şimdilik sabit tuttum
  let depth = -1500;  
  let shiftX = lerpX * (width * 0.3); // Ekran genişliğine göre kayma
  let shiftY = lerpY * (height * 0.2); // Ekran yüksekliğine göre kayma
  
  let steps = 9; 
  let gridResX = 4; 
  let gridResY = 3; 

  strokeWeight(2);

  for (let i = 0; i <= steps; i++) {
    let pct = i / steps;
    let z = pct * depth;
    let sX = pct * shiftX;
    let sY = pct * shiftY;

    let c = map(i, 0, steps, 200, 30);
    stroke(0, c, c * 0.85);

    push();
    translate(sX, sY, z);
    // Dinamik Aspect Ratio: Her katman ekranın mevcut oranını korur
    rect(0, 0, width, height);
    
    if (i === steps) {
        for (let j = 1; j < gridResX; j++) {
            let xPos = map(j, 0, gridResX, -width/2, width/2);
            line(xPos, -height/2, xPos, height/2);
        }
        for (let k = 1; k < gridResY; k++) {
            let yPos = map(k, 0, gridResY, -height/2, height/2);
            line(-width/2, yPos, width/2, yPos);
        }
    }
    pop();

    if (i < steps) {
      let nextPct = (i + 1) / steps;
      let nsX = nextPct * shiftX;
      let nsY = nextPct * shiftY;
      let nZ = nextPct * depth;

      for (let j = 0; j <= gridResX; j++) {
          let xOff = map(j, 0, gridResX, -width/2, width/2);
          line(xOff + sX, -height/2 + sY, z, xOff + nsX, -height/2 + nsY, nZ); 
          line(xOff + sX, height/2 + sY, z, xOff + nsX, height/2 + nsY, nZ);  
      }
      for (let k = 1; k < gridResY; k++) {
          let yOff = map(k, 0, gridResY, -height/2, height/2);
          line(-width/2 + sX, yOff + sY, z, -width/2 + nsX, yOff + nsY, nZ); 
          line(width/2 + sX, yOff + sY, z, width/2 + nsX, yOff + nsY, nZ);  
      }
    }
  }

  // 3. MERKEZDEKİ OBJE
  push();
  translate(shiftX * 0.5, shiftY * 0.5, depth * 0.5);
  rotateX(frameCount * 0.005);
  rotateY(frameCount * 0.002);
  stroke(255, 0, 100);
  // Obje boyutunu da ekranın küçüklüğüne göre ayarla
  let boxSize = min(width, height) * 0.3;
  box(boxSize);
  pop();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>