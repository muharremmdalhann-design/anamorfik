<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Anamorphic Mechanical Cube - Final Center Fix</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
    canvas { display: block; }
  </style>
</head>
<body>

<script>
let facemesh, handpose;
let video;
let faceX = 0, faceY = 0, lerpX = 0, lerpY = 0;
let cubeRotX = 0, cubeRotY = 0, lerpRotX = 0, lerpRotY = 0;

// Mekanik açılma değişkenleri
let explodeFactor = 0; 
let targetExplode = 0;
let cubeEdges = [];

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  
  // İşlemci rahatlasın diye çözünürlük ideal seviyede sınırlandı
  let constraints = {
    video: { width: { ideal: 320 }, height: { ideal: 240 } },
    audio: false
  };
  video = createCapture(constraints);
  video.hide();

  facemesh = ml5.facemesh(video, { maxFaces: 1 }, () => console.log("Yüz Takibi Aktif"));
  facemesh.on("predict", results => {
    // video.width > 0 kontrolü kameranın yüklendiğinden emin olmak içindir
    if (results.length > 0 && video.width > 0) {
      let p = results[0].scaledMesh[168];
      
      // İŞTE ÇÖZÜM: 640 veya 320 gibi sabit sayılar yerine video.width kullanıyoruz.
      // Bu sayede telefon dik de olsa yan da olsa merkez hep "tam orta" kalır!
      faceX = map(p[0], 0, video.width, 2.3, -2.3); 
      faceY = map(p[1], 0, video.height, -2.3, 2.3);
    }
  });

  handpose = ml5.handpose(video, () => console.log("El Takibi Aktif"));
  handpose.on("predict", results => {
    if (results.length > 0 && video.width > 0) {
      let lm = results[0].landmarks;
      cubeRotY = map(lm[9][0], 0, video.width, PI, -PI);
      cubeRotX = map(lm[9][1], 0, video.height, PI, -PI);
      
      let handSize = dist(lm[8][0], lm[8][1], lm[5][0], lm[5][1]);
      // El açılma eşiğini de ekran genişliğine oranladım (çözünürlük değişse de bozulmaz)
      targetExplode = handSize > (video.width * 0.15) ? 1 : 0; 
    }
  });

  // Küpün 12 kenarını ve her kenarın hangi yöne açılacağını (vektör) tanımla
  let s = 110; 
  cubeEdges = [
    {p1: createVector(-s,-s,-s), p2: createVector(s,-s,-s), dir: createVector(0,-1,-1)},
    {p1: createVector(s,-s,-s), p2: createVector(s,s,-s), dir: createVector(1,0,-1)},
    {p1: createVector(s,s,-s), p2: createVector(-s,s,-s), dir: createVector(0,1,-1)},
    {p1: createVector(-s,s,-s), p2: createVector(-s,-s,-s), dir: createVector(-1,0,-1)},
    {p1: createVector(-s,-s,s), p2: createVector(s,-s,s), dir: createVector(0,-1,1)},
    {p1: createVector(s,-s,s), p2: createVector(s,s,s), dir: createVector(1,0,1)},
    {p1: createVector(s,s,s), p2: createVector(-s,s,s), dir: createVector(0,1,1)},
    {p1: createVector(-s,s,s), p2: createVector(-s,-s,s), dir: createVector(-1,0,1)},
    {p1: createVector(-s,-s,-s), p2: createVector(-s,-s,s), dir: createVector(-1,-1,0)},
    {p1: createVector(s,-s,-s), p2: createVector(s,-s,s), dir: createVector(1,-1,0)},
    {p1: createVector(s,s,-s), p2: createVector(s,s,s), dir: createVector(1,1,0)},
    {p1: createVector(-s,s,-s), p2: createVector(-s,s,s), dir: createVector(-1,1,0)}
  ];
}

function draw() {
  background(0);
  lerpX = lerp(lerpX, faceX, 0.1);
  lerpY = lerp(lerpY, faceY, 0.1);
  lerpRotX = lerp(lerpRotX, cubeRotX, 0.1);
  lerpRotY = lerp(lerpRotY, cubeRotY, 0.1);
  
  explodeFactor = lerp(explodeFactor, targetExplode, 0.12);

  camera(0, 0, (height/2.0) / tan(PI*30.0 / 180.0), 0, 0, 0, 0, 1, 0);

  noFill(); stroke(0, 255, 200); strokeWeight(4);
  rectMode(CENTER);
  rect(0, 0, width, height);

  drawInterior();
}

function drawInterior() {
  let depth = -1000; 
  let shiftX = lerpX * 450; 
  let shiftY = lerpY * 300;
  
  strokeWeight(2);
  for (let i = 0; i <= 9; i++) {
    let pct = i / 9;
    let z = pct * depth;
    let sX = pct * shiftX;
    let sY = pct * shiftY;
    let c = map(i, 0, 9, 200, 30);
    stroke(0, c, c * 0.85);
    push();
    translate(sX, sY, z);
    rect(0, 0, width, height);
    if (i === 9) {
        for (let j = 1; j < 4; j++) {
            let xPos = map(j, 0, 4, -width/2, width/2);
            line(xPos, -height/2, xPos, height/2);
        }
        for (let k = 1; k < 3; k++) {
            let yPos = map(k, 0, 3, -height/2, height/2);
            line(-width/2, yPos, width/2, yPos);
        }
    }
    pop();

    if (i < 9) {
      let nPct = (i + 1) / 9;
      let nsX = nPct * shiftX, nsY = nPct * shiftY, nZ = nPct * depth;
      for (let j = 0; j <= 4; j++) {
          let xOff = map(j, 0, 4, -width/2, width/2);
          line(xOff + sX, -height/2 + sY, z, xOff + nsX, -height/2 + nsY, nZ); 
          line(xOff + sX, height/2 + sY, z, xOff + nsX, height/2 + nsY, nZ);  
      }
      for (let k = 1; k < 3; k++) {
          let yOff = map(k, 0, 3, -height/2, height/2);
          line(-width/2 + sX, yOff + sY, z, -width/2 + nsX, yOff + nsY, nZ); 
          line(width/2 + sX, yOff + sY, z, width/2 + nsX, yOff + nsY, nZ);  
      }
    }
  }

  // 3. MEKANİK KÜP
  push();
  translate(shiftX * 0.5, shiftY * 0.5, depth * 0.5);
  rotateX(lerpRotX);
  rotateY(lerpRotY);
  
  stroke(255, 0, 100); 
  strokeWeight(3);

  for (let edge of cubeEdges) {
    push();
    let moveDist = explodeFactor * 200; 
    translate(edge.dir.x * moveDist, edge.dir.y * moveDist, edge.dir.z * moveDist);
    line(edge.p1.x, edge.p1.y, edge.p1.z, edge.p2.x, edge.p2.y, edge.p2.z);
    pop();
  }
  pop();
}

function windowResized() { resizeCanvas(windowWidth, windowHeight); }
</script>
</body>
</html>
