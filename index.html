function drawInterior() {

  let depth = -800; 
  let shiftX = lerpX * 400;
  let shiftY = lerpY * 250;

  strokeWeight(1.2);

  let layers = 6;

  for (let i = 0; i <= layers; i++) {

    let pct = i / layers;
    let z = pct * depth;
    let sX = pct * shiftX;
    let sY = pct * shiftY;

    let c = map(i, 0, layers, 200, 40);
    stroke(0, c, c * 0.85);

    // sadece dış frame
    push();
    translate(sX, sY, z);
    rect(0, 0, width, height);
    pop();

    // köşe derinlik çizgileri (son katman hariç)
    if (i < layers) {

      let nextPct = (i + 1) / layers;
      let nz = nextPct * depth;
      let nsX = nextPct * shiftX;
      let nsY = nextPct * shiftY;

      let w = width / 2;
      let h = height / 2;

      // 4 köşe bağlantısı
      line(-w + sX, -h + sY, z, -w + nsX, -h + nsY, nz);
      line( w + sX, -h + sY, z,  w + nsX, -h + nsY, nz);
      line( w + sX,  h + sY, z,  w + nsX,  h + nsY, nz);
      line(-w + sX,  h + sY, z, -w + nsX,  h + nsY, nz);
    }
  }

  // CUBE
  push();
  translate(shiftX * 0.5, shiftY * 0.5, depth * 0.5);
  rotateX(lerpRotX);
  rotateY(lerpRotY);

  stroke(255, 0, 120);
  strokeWeight(2);

  let moveDist = explodeFactor * 180;

  for (let e of cubeEdges) {

    let ox = e[6] * moveDist;
    let oy = e[7] * moveDist;
    let oz = e[8] * moveDist;

    line(
      e[0]+ox, e[1]+oy, e[2]+oz,
      e[3]+ox, e[4]+oy, e[5]+oz
    );
  }

  pop();
}
