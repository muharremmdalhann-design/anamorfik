<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Anamorphic Cube - MediaPipe</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>

<style>
body { margin:0; overflow:hidden; background:black; }
video { display:none; }
canvas { display:block; }
</style>
</head>
<body>

<video id="video" autoplay playsinline></video>

<script type="module">

import {
  FaceLandmarker,
  HandLandmarker,
  FilesetResolver
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest";

let faceLandmarker, handLandmarker;
let video = document.getElementById("video");

let faceX = 0, faceY = 0;
let cubeRotX = 0, cubeRotY = 0;
let targetExplode = 0;

async function initMediaPipe(){

  const stream = await navigator.mediaDevices.getUserMedia({
    video:{ width:256, height:192 }
  });

  video.srcObject = stream;

  const vision = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
  );

  faceLandmarker = await FaceLandmarker.createFromOptions(vision,{
    baseOptions:{
      modelAssetPath:"https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/latest/face_landmarker.task",
      delegate:"GPU"
    },
    runningMode:"VIDEO",
    numFaces:1
  });

  handLandmarker = await HandLandmarker.createFromOptions(vision,{
    baseOptions:{
      modelAssetPath:"https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task",
      delegate:"GPU"
    },
    runningMode:"VIDEO",
    numHands:1
  });

  video.onloadeddata = () => loop();
}

let lastVideoTime = -1;

function loop(){

  if(video.currentTime !== lastVideoTime){
    lastVideoTime = video.currentTime;

    const now = performance.now();

    const faceResults = faceLandmarker.detectForVideo(video, now);
    const handResults = handLandmarker.detectForVideo(video, now);

    if(faceResults.faceLandmarks.length > 0){
      let p = faceResults.faceLandmarks[0][1]; // nose
      faceX = map(p.x,0,1,2.3,-2.3);
      faceY = map(p.y,0,1,-2.3,2.3);
    }

    if(handResults.landmarks.length > 0){
      let lm = handResults.landmarks[0];

      cubeRotY = map(lm[9].x,0,1,PI,-PI);
      cubeRotX = map(lm[9].y,0,1,PI,-PI);

      let dx = lm[8].x - lm[5].x;
      let dy = lm[8].y - lm[5].y;
      let size = Math.sqrt(dx*dx + dy*dy);

      targetExplode = size > 0.08 ? 1 : 0;
    }
  }

  requestAnimationFrame(loop);
}

initMediaPipe();


// ==================== P5 ====================

let lerpX=0, lerpY=0;
let lerpRotX=0, lerpRotY=0;
let explodeFactor=0;
let cubeEdges=[];

window.setup = function(){
  pixelDensity(1);
  createCanvas(window.innerWidth, window.innerHeight, WEBGL);

  let s=100;
  cubeEdges=[
    [-s,-s,-s,  s,-s,-s,  0,-1,-1],
    [ s,-s,-s,  s, s,-s,  1, 0,-1],
    [ s, s,-s, -s, s,-s,  0, 1,-1],
    [-s, s,-s, -s,-s,-s, -1, 0,-1],
    [-s,-s, s,  s,-s, s,  0,-1, 1],
    [ s,-s, s,  s, s, s,  1, 0, 1],
    [ s, s, s, -s, s, s,  0, 1, 1],
    [-s, s, s, -s,-s, s, -1, 0, 1],
    [-s,-s,-s, -s,-s, s, -1,-1, 0],
    [ s,-s,-s,  s,-s, s,  1,-1, 0],
    [ s, s,-s,  s, s, s,  1, 1, 0],
    [-s, s,-s, -s, s, s, -1, 1, 0]
  ];
};

window.draw = function(){

  background(0);

  lerpX = lerp(lerpX,faceX,0.1);
  lerpY = lerp(lerpY,faceY,0.1);
  lerpRotX = lerp(lerpRotX,cubeRotX,0.1);
  lerpRotY = lerp(lerpRotY,cubeRotY,0.1);
  explodeFactor = lerp(explodeFactor,targetExplode,0.15);

  camera(0,0,(height/2)/tan(PI*30/180),0,0,0,0,1,0);

  stroke(0,255,200);
  strokeWeight(1.5);
  noFill();
  rectMode(CENTER);
  rect(0,0,width,height);

  drawInterior();
};

function drawInterior(){

  let depth=-800;
  let shiftX=lerpX*400;
  let shiftY=lerpY*250;

  let layers=6;

  for(let i=0;i<=layers;i++){

    let pct=i/layers;
    let z=pct*depth;
    let sX=pct*shiftX;
    let sY=pct*shiftY;

    let c=map(i,0,layers,200,40);
    stroke(0,c,c*0.85);

    push();
    translate(sX,sY,z);
    rect(0,0,width,height);
    pop();

    if(i<layers){
      let next=(i+1)/layers;
      let nz=next*depth;
      let nsX=next*shiftX;
      let nsY=next*shiftY;

      let w=width/2;
      let h=height/2;

      line(-w+sX,-h+sY,z,-w+nsX,-h+nsY,nz);
      line( w+sX,-h+sY,z, w+nsX,-h+nsY,nz);
      line( w+sX, h+sY,z, w+nsX, h+nsY,nz);
      line(-w+sX, h+sY,z,-w+nsX, h+nsY,nz);
    }
  }

  push();
  translate(shiftX*0.5,shiftY*0.5,depth*0.5);
  rotateX(lerpRotX);
  rotateY(lerpRotY);

  stroke(255,0,120);
  strokeWeight(2);

  let moveDist=explodeFactor*180;

  for(let e of cubeEdges){
    let ox=e[6]*moveDist;
    let oy=e[7]*moveDist;
    let oz=e[8]*moveDist;

    line(
      e[0]+ox,e[1]+oy,e[2]+oz,
      e[3]+ox,e[4]+oy,e[5]+oz
    );
  }

  pop();
}

windowResized = function(){
  resizeCanvas(window.innerWidth, window.innerHeight);
};

</script>
</body>
</html>
