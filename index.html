<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Correct Anamorphic Center</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>

<script>
let facemesh;
let video;
let faceX = 0, faceY = 0;
let lerpX = 0, lerpY = 0;

function setup() {
  createCanvas(windowWidth, windowHeight, WEBGL);
  
  video = createCapture(VIDEO);
  video.size(640, 480);
  video.hide();

  facemesh = ml5.facemesh(video, () => console.log("Sistem Hazır"));
  facemesh.on("predict", results => {
    if (results.length > 0) {
      let p = results[0].scaledMesh[168];
      
      // MERKEZLEME BURADA: 
      // Kameranın tam ortasını (320, 240) SIFIR noktası yapıyoruz.
      // Böylece sen ortadayken shift değerleri de 0 olur, oda kaymaz.
      faceX = map(p[0], 0, 640, 2.3, -2.3); 
      faceY = map(p[1], 0, 480, -2.3, 2.3);
    }
  });
}

function draw() {
  background(0);

  // Yumuşatma (Titremeyi engellemek için biraz daha ağırlaştırdım)
  lerpX = lerp(lerpX, faceX, 0.1);
  lerpY = lerp(lerpY, faceY, 0.1);

  camera(0, 0, (height/2.0) / tan(PI*30.0 / 180.0), 0, 0, 0, 0, 1, 0);

  // 1. SABİT ÖN ÇERÇEVE (Ekrana çakılı)
  noFill();
  stroke(0, 255, 200);
  strokeWeight(4);
  rectMode(CENTER);
  rect(0, 0, width, height);

  drawInterior();
}

function drawInterior() {
  let depth = -1500; 
  // Kayma miktarını senin o sevdiğin koddaki gibi sabitliyoruz
  let shiftX = lerpX * 450; 
  let shiftY = lerpY * 300;
  
  let steps = 9; 
  let gridResX = 4; 
  let gridResY = 3; 

  strokeWeight(2);

  for (let i = 0; i <= steps; i++) {
    let pct = i / steps;
    let z = pct * depth;
    let sX = pct * shiftX;
    let sY = pct * shiftY;

    let c = map(i, 0, steps, 200, 30);
    stroke(0, c, c * 0.85);

    push();
    translate(sX, sY, z);
    rect(0, 0, width, height);
    
    if (i === steps) {
        for (let j = 1; j < gridResX; j++) {
            let xPos = map(j, 0, gridResX, -width/2, width/2);
            line(xPos, -height/2, xPos, height/2);
        }
        for (let k = 1; k < gridResY; k++) {
            let yPos = map(k, 0, gridResY, -height/2, height/2);
            line(-width/2, yPos, width/2, yPos);
        }
    }
    pop();

    if (i < steps) {
      let nextPct = (i + 1) / steps;
      let nsX = nextPct * shiftX;
      let nsY = nextPct * shiftY;
      let nZ = nextPct * depth;

      for (let j = 0; j <= gridResX; j++) {
          let xOff = map(j, 0, gridResX, -width/2, width/2);
          line(xOff + sX, -height/2 + sY, z, xOff + nsX, -height/2 + nsY, nZ); 
          line(xOff + sX, height/2 + sY, z, xOff + nsX, height/2 + nsY, nZ);  
      }
      for (let k = 1; k < gridResY; k++) {
          let yOff = map(k, 0, gridResY, -height/2, height/2);
          line(-width/2 + sX, yOff + sY, z, -width/2 + nsX, yOff + nsY, nZ); 
          line(width/2 + sX, yOff + sY, z, width/2 + nsX, yOff + nsY, nZ);  
      }
    }
  }

  // 3. MERKEZDEKİ OBJE
  push();
  translate(shiftX * 0.5, shiftY * 0.5, depth * 0.5);
  rotateX(frameCount * 0.005);
  rotateY(frameCount * 0.002);
  stroke(255, 0, 100);
  strokeWeight(3);
  box(220);
  pop();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}
</script>
</body>
</html>
