<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Anamorphic Cube Optimized</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
<script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

<style>
body { margin:0; overflow:hidden; background:#000; touch-action:none; }
canvas { display:block; }
</style>
</head>
<body>

<script>
let facemesh, handpose;
let video;

let faceX = 0, faceY = 0;
let lerpX = 0, lerpY = 0;

let cubeRotX = 0, cubeRotY = 0;
let lerpRotX = 0, lerpRotY = 0;

let explodeFactor = 0;
let targetExplode = 0;

let cubeEdges = [];

let frameCounter = 0;

function setup() {
  pixelDensity(1); // mobil için çok önemli
  createCanvas(windowWidth, windowHeight, WEBGL);

  let constraints = {
    video: { width: { ideal: 256 }, height: { ideal: 192 } },
    audio: false
  };

  video = createCapture(constraints);
  video.size(256,192);
  video.hide();

  // FACEMESH OPTIMIZED
  facemesh = ml5.facemesh(video, {
    maxFaces: 1,
    refineLandmarks: false
  }, () => console.log("Face active"));

  facemesh.on("predict", results => {
    if (frameCounter % 3 !== 0) return;
    if (results.length > 0) {
      let p = results[0].scaledMesh[168];
      faceX = map(p[0], 0, video.width, 2.3, -2.3);
      faceY = map(p[1], 0, video.height, -2.3, 2.3);
    }
  });

  // HANDPOSE OPTIMIZED
  handpose = ml5.handpose(video, () => console.log("Hand active"));

  handpose.on("predict", results => {
    if (frameCounter % 3 !== 0) return;
    if (results.length > 0) {
      let lm = results[0].landmarks;
      cubeRotY = map(lm[9][0], 0, video.width, PI, -PI);
      cubeRotX = map(lm[9][1], 0, video.height, PI, -PI);

      let handSize = dist(lm[8][0], lm[8][1], lm[5][0], lm[5][1]);
      targetExplode = handSize > (video.width * 0.15) ? 1 : 0;
    }
  });

  // CUBE EDGES
  let s = 100;
  cubeEdges = [
    [-s,-s,-s,  s,-s,-s,  0,-1,-1],
    [ s,-s,-s,  s, s,-s,  1, 0,-1],
    [ s, s,-s, -s, s,-s,  0, 1,-1],
    [-s, s,-s, -s,-s,-s, -1, 0,-1],
    [-s,-s, s,  s,-s, s,  0,-1, 1],
    [ s,-s, s,  s, s, s,  1, 0, 1],
    [ s, s, s, -s, s, s,  0, 1, 1],
    [-s, s, s, -s,-s, s, -1, 0, 1],
    [-s,-s,-s, -s,-s, s, -1,-1, 0],
    [ s,-s,-s,  s,-s, s,  1,-1, 0],
    [ s, s,-s,  s, s, s,  1, 1, 0],
    [-s, s,-s, -s, s, s, -1, 1, 0]
  ];
}

function draw() {
  frameCounter++;
  background(0);

  lerpX = lerp(lerpX, faceX, 0.1);
  lerpY = lerp(lerpY, faceY, 0.1);
  lerpRotX = lerp(lerpRotX, cubeRotX, 0.1);
  lerpRotY = lerp(lerpRotY, cubeRotY, 0.1);
  explodeFactor = lerp(explodeFactor, targetExplode, 0.15);

  camera(0,0,(height/2.0)/tan(PI*30.0/180.0),0,0,0,0,1,0);

  strokeWeight(width < 600 ? 1.5 : 3);
  stroke(0,255,200);
  noFill();
  rectMode(CENTER);
  rect(0,0,width,height);

  drawInterior();
}

function drawInterior() {

  let depth = -800; 
  let shiftX = lerpX * 400;
  let shiftY = lerpY * 250;

  strokeWeight(1.2);

  // LAYER 6 (10 yerine)
  for (let i=0; i<=6; i++) {

    let pct = i/6;
    let z = pct * depth;
    let sX = pct * shiftX;
    let sY = pct * shiftY;

    let c = map(i,0,6,200,40);
    stroke(0,c,c*0.85);

    push();
    translate(sX,sY,z);
    rect(0,0,width,height);
    pop();
  }

  // CUBE (push/pop kaldırıldı)
  push();
  translate(shiftX*0.5, shiftY*0.5, depth*0.5);
  rotateX(lerpRotX);
  rotateY(lerpRotY);

  stroke(255,0,120);
  strokeWeight(2);

  let moveDist = explodeFactor * 180;

  for (let e of cubeEdges) {

    let ox = e[6] * moveDist;
    let oy = e[7] * moveDist;
    let oz = e[8] * moveDist;

    line(
      e[0]+ox, e[1]+oy, e[2]+oz,
      e[3]+ox, e[4]+oy, e[5]+oz
    );
  }

  pop();
}

function windowResized(){
  resizeCanvas(windowWidth, windowHeight);
}
</script>

</body>
</html>
